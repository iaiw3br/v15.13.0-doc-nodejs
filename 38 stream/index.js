const stream = require('stream');
const fs = require('fs');
const http = require('http');
/*
* Потоки это абстрактный интерфейс для работы с потоками данными в Node.js.
* Все потоки являются EventEmitter-ами.
*
* Документация включает два основным раздела и третий раздел для примечаний.
* Типы потоков:
* Writable - поток, которые записывает данные fs.createWriteStream();
* Readable - поток, который читает данные fs.createReadStream();
* Duplex - стрим для чтения и записи
* Transform - Duplex поток, который может изменять или трансформировать данные по мере их записи или чтения.
* Дополнительно, этот модуль включает дополнительные функции: stream.pipeline(), stream.finished(),
* stream.Readable.from(), stream.addAbortSignal().
*
* Streams Promises API
* Предоставляет альтернативный набор асинхронных служебных функции для потоков, которые возвращают
* объекты Promise, а не функция обратного вызова.
*
* Object mode
* Все потоки созданные API Node.js работают со строками и Buffer (or Uint8Array) объектами (за исключением null).
* Экземпляр потоков переключается в режим объекта используя objectMode опцию, когда поток создаётся.
* Попытка переключиться существующий поток в режим объекта не безопасен.
*
*
* Buffering
* Оба Writable and Readable будут хранить данные во внутренним буфере.
* Можно изменять количество данных в потоке с помощью highWaterMark (значение в байтах).
* Для потоков, которые работают в режиме объекта, highWaterMark указывается общее число объектов.
*
* Данные буферезированные в Readable потоке, когда выполняется вызов stream.push(chunk). Если потребитель
* потока не вызывает stream.read(), данные будут находится во внутренней очереди, пока не будут использованы.
*
* Когда размер внутреннего буфера чтения достигает порога, указанного в highWaterMark, поток будет временно
* останавливаться для чтения данных из до тех пор, пока буферизированные данные не будут использованы.
* Т.е. поток перестанет вызывать stream._read() для заполнения чтения буфера.
*
* Данные буферизируются в потоках с возможностью записи, когда метод writable.write(chunk) вызывается повторно.
* Пока общий размер внутренней данных будет ниже порога highWaterMark, будет вызываться writable.write(),
* который вернёт true, когда размер превысит, тогда вернётся false.
*
* Ключевая роль API потоков, в частности stream.pipe() метода является ограничение данных до приемлемых уровней,
* чтобы источники и места назначения с разными скоростями не перегружали доступную память.
*
* highWaterMark это порог, а не лимит. Он определяет объём данных, которые поток буферизирует, прежде чем он
* перестанет запрашивать дополнительные данные.
*
* Так как Duplex и Transform потоки оба Readable и Writable, каждый поддерживает два отдельных внутренних
* буфера.
* */
// const server = http.createServer((req, res) => {
//     let body = '';
//     req.setEncoding('utf8');
//     req.on('data', chunk => body += chunk);
//     req.on('end', () => {
//         try {
//             const data = JSON.parse(body);
//             res.write(typeof data);
//             res.end();
//         } catch (err) {
//            res.statusCode = 400;
//            return res.end(`error: ${err.message}`);
//         }
//     });
// }).listen(3000);

/*
* Writable потоки предоставляют такие методы, как write(), end() которые используются для записи данных в поток.
* Readable, Writable потоки используют EventEmitter API для уведомления приложения, когда данные буду доступны из потока.
* Duplex, Transform потоки оба Readable, Writable.
* */


/*
* Потоки используются в:
* http request
* http response
* fs write stream
* zlib stream
* crypto stream
* TCP sockets
* child process stdin
* */


/*
* Class: stream.Writable
* Class: stream.Writable
*
* event: close - событие вызывается, когда поток закрывается. Событие указывает, что нет больше событий.
* event: drain - когда необходимо возобновить запись данных в поток.
* event: error - если при записи возникнет ошибка. Поток закроется, когда будет произведён вызов события.
* event: finish - событие сработает после stream.end()
* event: pipe - когда метод вызовет поток чтения
* event: unpipe - при вызове stream.unpipe(), вызывается из Readable потока,
* */
