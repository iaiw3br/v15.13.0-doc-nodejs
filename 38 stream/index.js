const stream = require('stream');
const fs = require('fs');
/*
* Потоки это абстрактный интерфейс для работы с потоками данными в Node.js.
* Все потоки являются EventEmitter-ами.
*
* Документация включает два основным раздела и третий раздел для примечаний.
* Типы потоков:
* Writable - поток, которые записывает данные fs.createWriteStream();
* Readable - поток, который читает данные fs.createReadStream();
* Duplex - стрим для чтения и записи
* Transform - Duplex поток, который может изменять или трансформировать данные по мере их записи или чтения.
* Дополнительно, этот модуль включает дополнительные функции: stream.pipeline(), stream.finished(),
* stream.Readable.from(), stream.addAbortSignal().
*
* Streams Promises API
* Предоставляет альтернативный набор асинхронных служебных функции для потоков, которые возвращают
* объекты Promise, а не функция обратного вызова.
*
* Object mode
* Все потоки созданные API Node.js работают со строками и Buffer (or Uint8Array) объектами (за исключением null).
* Экземпляр потоков переключается в режим объекта используя objectMode опцию, когда поток создаётся.
* Попытка переключиться существующий поток в режим объекта не безопасен.
*
*
* Buffering
* Оба Writable and Readable будут хранить данные во внутренним буфере.
* Можно изменять количество данных в потоке с помощью highWaterMark (значение в байтах).
* Для потоков, которые работают в режиме объекта, highWaterMark указывается общее число объектов.
*
* Данные буферезированные в Readable потоке, когда выполняется вызов stream.push(chunk). Если потребитель
* потока не вызывает stream.read(), данные будут находится во внутренней очереди, пока не будут использованы.
*
* Когда размер внутреннего буфера чтения достигает порога, указанного в highWaterMark, поток будет временно
* останавливаться для чтения данных из до тех пор, пока буферизированные данные не будут использованы.
* Т.е. поток перестанет вызывать stream._read() для заполнения чтения буфера.
*
* Данные буферизируются в потоках с возможностью записи, когда метод writable.write(chunk) вызывается повторно.
* Пока общий размер внутренней данных будет ниже порога highWaterMark, будет вызываться writable.write(),
* который вернёт true, когда размер превысит, тогда вернётся false.
*
* Ключевая роль API потоков, в частности stream.pipe() метода является ограничение данных до приемлемых уровней,
* чтобы источники и места назначения с разными скоростями не перегружали доступную память.
*
* highWaterMark это порог, а не лимит. Он определяет объём данных, которые поток буферизирует, прежде чем он
* перестанет запрашивать дополнительные данные.
*
* */
